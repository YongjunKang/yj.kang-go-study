# 배열(Array)

Go 언어에서는 두 개 이상의 변수를 모아 놓은 것을 '컬렉션' 이라고 합니다.

배열을 포함한 컬렉션은 다수의 데이터를 저장하고 처리하는 경우에 유용하고 굉장히 많이 쓰입니다.

Go언어에서의 배열은 정적입니다.
즉, __고정된 배열 크기__ 안에 동일한 데이터를 연속적으로 저장할 수 있다는 뜻입니다.

크기를 동적으로 증가시키거나 부분 배열을 발췌하는 등의 기능을 가지고 있지 않습니다.

```go
var 배열이름 [배열크기]자료형
```

__Go언어에서는 배열의 크기는 자료형을 구성하는 한 요소입니다.__
따라서, `[3]int`와 `[5]int`는 `string`과 `float32`처럼 타입 자체가 다른 것입니다.

배열의 요소는 인덱스를 사용하여 읽거나 쓸 수 있습니다.

```go
// 배열을 선언하고 읽고 쓰는 예제
package main

import "fmt"

func main() {
	var arr1 [5]int   //길이가 5인 int형 배열 arr1을 선언
	fmt.Println(arr1) //숫자를 선언하지 않고 출력해보기

	arr1 = [5]int{1, 2, 3, 4, 5}        //배열 초기화
	fmt.Println(arr1, arr1[0], arr1[4]) //배열 전체와 인덱스에 저장된 값들 출력해보기

	arr2 := [4]int{4, 5, 6, 7} //:= 를 이용해 선언
	arr2[0] = 32               //인덱스를 이용해 값을 초기화
	fmt.Println(arr2)          //arr2 전체 출력해보기

	var arr3 = [...]int{9, 8, 7, 6} //[...]을 이용한 배열 크기 자동 설정
	fmt.Println(arr3, len(arr3))    //arr3 전체와  배열 크기 출력해보기
}
```
###### 결과

```go
> [0 0 0 0 0]
[1 2 3 4 5] 1 5
[32 5 6 7]
[9 8 7 6] 4
```

내장 함수 len()을 사용하면 배열의 길이(요소의 개수)를 알 수 있습니다.
[...] 용법을 사용하면 배열 크기를 자동으로 설정해줍니다.

__그렇다고해서 이후에 크기를 바꿀 수 있는 것은 아닙니다.__

## 다차원 배열
Go언어도 다차원 배열을 지원합니다.

```go
var multiArray [2][3][4]int // 3차원 배열 선언
multiArray[1][1][2] = 10 // 인덱스를 이용한 값 초기화
```
```go
> [[[0 0 0 0] [0 0 0 0] [0 0 0 0]] [[0 0 0 0] [0 0 10 0] [0 0 0 0]]]
```

배열을 행렬과 같은 형태로 보기 쉽게 묶어서 초기화할 수 있습니다.
차원은 얼마든지 늘릴 수 있지만 4차원 이상은 거의 쓰이지 않습니다.

```go
package main

import "fmt"

func main() {
    var a = [3][3]int{
		{1, 2, 3},        
		{4, 5, 6},
		{7, 8, 9}, //3x3배열 초기화
    }
	
    fmt.Println(a[1][2]) //2행 3열의 값 출력
}
```
###### 결과
```go
> 6
```

## 슬라이스(Slice)
Slice는 배열과 다르게 __고정된 크기를 미리 지정하지 않고 이후에 필요에 따라 크기를 동적으로 변경__ 할 수 있고, __부분 발췌__ 가 가능합니다.

__슬라이스는 지금까지 배운 자료형과 내부적인 구조가 다르기때문에 선언 및 초기화를 할 때 주의해야합니다.__

예를 들어
```go
var num int
```
의 선언은 __한개의 int형의 변수가 들어갈 메모리를 만들었다.__ 라는 말이비다.

아무런 값을 초기화 하지 않고 선언만 해도 0, ""(빈칸)과 같이 자료형에 맞는 값이 자동 할당되는데 이는 선언과 동시에 자동 초기화된다는 것과 같은 말입니다.

다른 자료형과 마찬가지로, 배열도 크기를 지정하고 선언하기 때문에 명시한 개수만큼의 메모리를 만듭니다.

```go
var arr2 [3]int
```
3개의 int타입의 변수가 들어갈 메모리를 만들고, 초기화하지 않았기 때문에 자동으로 0이 할당됩니다.

선언만 했을 뿐인데 len()함수를 이용해 배열의 크기가 3이라는 것을 확인할 수 있습니다.

하지만 슬라이스를 위에서 설명한 것과 같은 방법으로
```go
var a []int
```
와 같이 선언한다면 __배열의 일부분을 가리키는 포인터를 만듭니다.__

선언만 하고 초기화를 하지 않아서 슬라이스의 정보만 있는 배열만 생성되고, 실질적으로 어떠한 변수가 들어갈 공간(메모리)는 생성되지 않습니다.

슬라이스는 크기를 미리 지정하지 않기 때문에 컴퓨터가 어디서부터 어디까지 0이나 ""으로 채워야하는지 알 수 없기 때문입니다.

따라서 선언만 한다면 'Nil silce'가 됩니다.
이것은 크기도 용량도 없는 상태를 의미합니다.
메모리를 만들지 않아서 존재하지도 않기 때문에 a[0] = 1 과 같이 값을 지정할 수 없습니다.

|슬라이스 구조|
|-------------|
|prt *Elem|
|len int|
|cap int|

기본적으로 슬라이스는 아무런 값도 초기화하지 않아도 배열의 위치를 가리키는 __ptr__ 과 배열의 길이인 __len__, 전체크기인 __cap__ 메모리를 가지고 있습니다.

그렇기 때문에 슬라이스를 `var a []int`와 같이 선언을 할 때는 주로 `var a []int = []int{1, 2, 3, 4} 같이 선언과 동시에 값을 초기화할 때만 사용합니다.

__슬라이스를 선언함과 동시에 1,2,3,4를 위한 메모리를 만든다는 뜻입니다.__

배열은 다른 배열의 값을 대입하면 값 자체가 대입됩니다.
슬라이스는 참조 타입이기 때문에 __슬라이스를 복사해혼다는 것은 사실 같은 주소를 참조한다는 것__ 과 같은 말입니다.

슬라이스는 다른 슬라이스를 부분 복사할 수 있는 기능이 있는데 슬라이스 a를 부분 복제하려고 하는 슬라이스 l은 l = a[2:5]를 입력함으로써 슬라이스 a의 인덱스 2요소부터 4요소까지 참조합니다.

슬라이스는 데이터의 복사 없이 데이터를 사용 할 수 있다는 장점이 있습니다.

참고로 슬라이스의 길이와 용량을 지정하지 않고 슬라이스를 선언만 해서 Nil slice를 만들면, nil 과 비교할 수 있고 true값을 반환합니다.

```go
package main

import "fmt"

func main() {
	var a []int        //슬라이스 변수 선언 아무것도 초기화 되지 않은 상태
	a = []int{1, 2, 3} //슬라이스에 리터럴값 지정

	a[1] = 10 //값이 할당되어 메모리가 생겼기 때문에 이렇게 접근 가능

	fmt.Println(a)

	var b []int //nil slice 선언

	if b == nil {
		fmt.Println("용량이", cap(b), "길이가", len(b), " Nil Slice입니다.")
	}
}mt.Println(a[1][2]) //2행 3열의 값 출력
}
```
```go
> [1 10 3]
용량이 0 길이가 0  Nil Slice입니다.
```

## make() 함수를 이용한 슬라이스 선언
슬라이스를 선언만 하면서 크기를 미리 지정할 수 있는 방법
즉, 값을 저장할 수 있는 메모리를 선언만 함으로써 생성한다.

슬라이스를 생성함과 동시에 슬라이스의 길이(len), 슬라이스의 용량(cap)을 저장할 수 있습니다.

```
make(슬라이스 타입, 슬라이스 길이, 슬라이스의 용량)
```

여기서 용량(Capacity)은 생략해서 선언할 수 있습니다.
용량을 생략한다면 슬라이스의 길이와 똑같은 값으로 선언됩니다.

make() 함수를 이용해 선언한다면 비로소 모든 요소가 0인 슬라이스를 만들게 됩니다.

- 길이 : 초기화된 슬라이스의 요소 개수
  - 즉 슬라이스에 5개의 값이 초기화된다면 길이는 5가 됩니다.
  - 그 후에 값을 추가하거나 삭제한다면 그만큼 길이가 바뀌게 됩니다.
  - `len(컬렉션이름)`으로 길이를 알 수 있습니다.
- 용량 : 슬라이스는 배열의 길이가 동적으로 늘어날 수 있기 때문에 __길이와 용량을 구분__ 합니다.
  - 동호회에서 야유회를 가기위해 버스를 대절한다고 생각해봅시다.
  - 야유회를 가기 위해 모인 인원은 125명이고 버스는 25인승입니다.
  - 125명은 배정이 완료되어서 버스를 5대 대절했습니다.
  - 16명이 추가로 가고 싶다고 할때 추가로 25인승짜리 버스 한 대를 더 대절했습니다.
  - 여기서 총 승객 136명은 "길이"입니다. 버스가 한번에 태울 수 있는 승객은 "용량" 입니다.
  - 선언한 슬라이스의 용량이 25인데 101개의 값을 초기화 하기 위해서 125의 용량이 필요하게 됩니다.
  - 이러한 방식으로 메모리를 관리하는 것이고 용량은 `cap(컬렉션이름)`으로 확인합니다.

  ###### 주의사항
  make() 함수를 이용해 슬라이스의 메모리를 할당하고 난 후에 []int{1,2,3,4}와 같은 식으로 입력하여 값을 초기화하면 __새로운 메모리를 할당하면서 그 전의 값은 없어집니다.__
  </br>
  기존의 메모리를 사용하고 값을 추가하기 위해서는 `append()` 함수를 사용해야 합니다.


```go
package main

import "fmt"

func main() {
	s := make([]int, 0, 3) // len=0, cap=3 인 슬라이스 선언

	for i := 1; i <= 10; i++ { // 1부터 차례대로 한 요소씩 추가
		s = append(s, i)

		fmt.Println(len(s), cap(s)) // 슬라이스 길이와 용량 확인
	}

	fmt.Println(s) // 최종 슬라이스 출력
}
```
```go
> 1 3
2 3
3 3
4 6
5 6
6 6
7 12
8 12
9 12
10 12
[1 2 3 4 5 6 7 8 9 10]
```

## 슬라이스 추가, 병합, 복사
__append() 함수를 이용해서 슬라이스에 데이터를 추가할 수 있습니다.__

슬라이스 용량이 남아있는 경우에는 그 용량 내에서 슬라이스의 길이를 변경하여 데이터를 추가하고, 용량이 초과하는 경우에는 설정한 용량만큼 새로운 배열을 생성하고 기존 배열 값들을 모두 새 배열에 복제한 후 다시 슬라이스를 할당하는 방식입니다.

__슬라이스에 슬라이스를 추가해서 붙일 수 있습니다.__ 주의할 점은 추가하는 슬라이스 뒤에 "..."을 입력해야 한다는 것입니다.
슬라이스의 모든 요소들의 집합을 표현하는 것으로 아래 예제의 "sliceB..."은 슬라이스의 요소 집합인 {4, 5, 6}으로 치환되는 것입니다.

__사실상 슬라이스에 슬라이스를 추가하는 것이 아니라, sliceA에{4,5,6}이라는 요소들이 추가되는 것입니다.__

```go
package main
 
import "fmt"
 
func main() {
    sliceA := []int{1, 2, 3}
    sliceB := []int{4, 5, 6}
 
    sliceA = append(sliceA, sliceB...)
    //sliceA = append(sliceA, 4, 5, 6)
 
    fmt.Println(sliceA) // [1 2 3 4 5 6] 출력
}
```
```go
> [1 2 3 4 5 6]
```

copy() 함수를 이용해 한 슬라이스를 다른 슬라이스로 복사할 수 있습니다.

```
copy(붙여넣을 슬라이스, 복사할 슬라이스)
```
복사할 슬라이스와 붙여넣을 슬라이스 모두 선언이 선행돼야 합니다.

```go
package main

import "fmt"

func main() {
	sliceA := []int{0, 1, 2}
	sliceB := make([]int, len(sliceA), cap(sliceA)*2) //sliceA에 2배 용량인 슬라이스 선언

	copy(sliceB, sliceA)                              //A를 B에 붙여넣는다

	fmt.Println(sliceB)                               // [0 1 2 ] 출력
	println(len(sliceB), cap(sliceB))                 // 3, 6 출력
}
```
```go
> [0 1 2]
3 6
```

슬라이스의 부분만 잘라서 복사할 수도 있습니다.
```
붙여넣을 슬라이스 := 복사할 슬라이드[복사할 첫 인덱스:복사할 마시작 인덱스+1]
```
이라고 하면 잘라서 복사할 수 있습니다.

```
l := sliceA[2:5]
```
라고 한다면 슬라이스 l에 sliceA의 인덱스 2요소부터 4요소까지 잘라서 복사한다는 것입니다.
__마지막 요소는 복사하지 않습니다.__
그리고 처음과 마지막 인덱스를 생력하면 첫 요소와 맨 마지막 요소를 의미합니다.
```
l := sliceA[:5]
```
라면 sliceA의 처음부터 인덱스 4의 요소까지 복사하다는 것입니다.

```go
package main

import "fmt"

func main() {
	c := make([]int, 0, 3) //용량이 3이고 길이가0인 정수형 슬라이스 선언
	c = append(c, 1, 2, 3, 4, 5, 6, 7)
	fmt.Println(len(c), cap(c))

	l := c[1:3] //인덱스 1요소부터 2요소까지 복사
	fmt.Println(l)

	l = c[2:] //인덱스 2요소부터 끝까지 복사
	fmt.Println(l)

	l[0] = 6

	fmt.Println(c) //슬라이스 l의 값을 바꿨는데 c의 값도 바뀜
	//값을 복사해온 것이 아니라 기존 슬라이스 주솟값을 참조
}
```
```go
> 7 8
[2 3]
[3 4 5 6 7]
[1 2 6 4 5 6 7]
```

__슬라이스는 배열과 다르게 값을 복사해오는 것이 아니라 슬라이스 자체가 참조하고있는 주소값을 같이 참조하는 것을 의미하지 때문입니다.__

그래서 복사해온 슬라이스의 값을 바꿨는데 기존 복사한 슬라이스의 값도 바뀐 것을 확인할 수 있습니다.
같은 상황에 배열은 단순히 값을 복사해서 초기화합니다.

## 맵(Map)
배열과 슬라이스는 인덱스 번호를 임의대로 바꿀 수 없습니다.
단어 사전을 배열 혹은 슬라이스로 만든다고 가정 했을때, 단어를 추가할 때마다 인덱스 0번부터 순차적으로 저장하고 해당하는 인덱스 번호를 통해 값을 쓰거나 저장할 수 있는게 전부 입니다.

사전의 고유 형태인 "단어:뜻" 형태로 저장할 수 없습니다.
필요한 것이 바로 key 값과 그에 해당하는 value 값을 매핑해 저장하는 'Hash table' 입니다.

Rudy에서의 hash와 python에서의 dicts와 같은 기능을 합니다.
map은 "key:value" 형식으로 값을 매핑해서 저장합니다.

사전을 예로 "love:사랑, root:뿌리, submit:제출하다"와 같은 형식으로 값을 저장할 수 있습니다.

그리고 맵과 슬라이스는 모두 값을 직접적으로 저장하는 것이 아닌 "참조 타입(Reference type)"이라는 점입니다.

선언과 값을 초기화 함에 있어서 슬라이스와 같은 방법과 이유를 가진다고 생각하면 됩니다.

```
var 맵이름 map[key자료형]value 자료형"
```
int형 key값과 string형 value값을 가지는 a라는 이름의 맵을 선언할 때는 `var a map[int]string`과 같이 선언할 수 있습니다.

선언만 하고 값을 초기화하지 않았다면 'Nil map'이 됩니다.

```go
package main

import "fmt"

func main() {
	var a map[int]string

	if a == nil {
		fmt.Println("nil map")
	}

	var m = map[string]string{ //key:value, 형식으로 초기화한다
		"apple":  "red",
		"grape":  "purple",
		"banana": "yellow",
	}

	fmt.Println(m, "\nm의 길이는", len(m))
}
```
```go
> nil map
map[apple:red grape:purple banana:yellow] 
m의 길이는 3
```

## map 변수의 추가, 갱신, 삭제
맵 컬렉션에 메모리가 할당(make() 함수 혹은 {}를 사용한 값 초기화) 됐으면 값을 추가, 갱신, 삭제할 수 있습니다.

슬라이스는 값을 추가하기 위해 append() 함수를 사용했지만, 맵에서의 key 값은 특별(unique)하기 때문에 `맵이름[key] = value` 형식으로 값을 추가할 수 있습니다.

__이미 있는 key값에 다시 다른 value값을 저장한다면 최근 저장한 값으로 갱신됩니다.__

`delete()` 함수를 이용해 저장된 값을 삭제할 수 있습니다.
`delete(맵이름, key)` 형식으로 key값에 해당되는 value값이 같이 삭제됩니다.

```go
package main

import "fmt"

func main() {
	//지역번호와 지역 저장
	var m = make(map[string]string)

	m["02"] = "서울특별시"
	m["031"] = "경기도"
	m["032"] = "충청남도"
	m["053"] = "대구광역시"

	fmt.Println(m)

	//동일한 key값으로 value값을 저장하면 갱신이 된다
	m["032"] = "인천"

	fmt.Println(m)

	//m에 있는 "031"key의 value와 함께 삭제
	delete(m, "031")

	fmt.Println(m)
}
```
```go
> map[02:서울특별시 031:경기도 032:충청남도 053:대구광역시]
map[02:서울특별시 031:경기도 032:인천 053:대구광역시]
map[032:인천 053:대구광역시 02:서울특별시]
```

## Map의 key 체크와 value 읽기
key가 사용되고 있는지(occupied), 만약 사용된다면 어떤 value값이 저장돼 있는지 알아야 할때가 있습니다.

이럴때 `맵이름[key]`의 값을 반환하면 됩니다.

`컬렉션이름[인덱스]`를 의미하는데 앞서 배열과 슬라이스는 해당 컬렉션의 인덱스에 저장돼 있는 값을 반환했습니다.
배열이나 슬라이스의 arr[3]은 인덱스 3에 저장된 값을 반환합니다.
인덱스의 범위를 넘는다면 에러가 발생합니다.

`맵이름[key]`는 __key에 저장돼 있는 value 값을 반환할 뿐만 아니라, 해당 키에 값이 존재하는지 안 하는지 즉, 사용하고 있는 key 값인지 아닌지 판별해주는 true/false 값도 반환합니다.__

존재하지 않는 key 값을 입력했다면 자료형에 따라 0이나 ""이 반환됩니다.

###### 주의할 점
- 1. 콘솔 출력 함수에 "맵이름[key]"을 바로 입력할 때는 key값에 해당되는 value 값만 출력됩니다.
- 2. value값과 true/false 값을 반환받기 위해서는 변수 두 개를 선언한 후에 각각 할당받아야 합니다.
  - 예로 val, exitst := 맵이름[key] 형식으로 입력해야만 val에는 value값이 exist에는 true/false 값이 초기화 됩니다.
- 3. value 값만 반환받고 싶다면 변수 한 개만 선언해 할당받으면 됩니다.
  - 예로 val := 맵이름[key]형식으로 입력하면 val에 value 값이 초기화 됩니다. __꼭 두 개의 값을 반환하는 것은 아닙니다.__
- 4. ture/false 값만 반환받고 싶다면 "_,bool변수" 형식으로 선언해 할당 받으면 됩니다. 
  - 예로 _, exist := 맵이름[key] 형식으로 입력하면 exist에 true/false 값이 초기화 됩니다.
  - 왜냐하면 `맵이름[key]는 꼭 'value, true/false` 순서로 반환하기 때문입니다.

```go
package main

import "fmt"

func main() {
	//지역번호와 지역 저장
	var m = make(map[string]string)

	m["02"] = "서울특별시"
	m["031"] = "경기도"
	m["032"] = "인천"
	m["053"] = "대구광역시"

	fmt.Println(m["032"])
	fmt.Println(m["042"], "빈 칸입니다.") //string형태로 존재하지 않는 key값은 ""가 출력된다

	val, exist := m["02"] //존재하는 key
	fmt.Println(val, exist)

	val, exist = m["042"] //존재하지 않는 key
	fmt.Println(val, exist)

	val = m["053"] //value 값만 반환
	fmt.Println(val)

	_, exist = m["053"] //true/false 값만 반환
	fmt.Println(exist)

	//맵도 똑같이 len() 함수를 사용할 수 있다 하지만 cap() 함수는 사용할 수 없다
	fmt.Println(len(m))
}
```
```go
인천
 빈 칸입니다.
서울특별시 true
 false
대구광역시
true
4
```

# 역행렬
```go
package main

import "fmt"

func main() {
	var arrA = [2][2]int {
		{7,3},
		{5,2},
	}
	
	arrB := [2][2]int {}
	
	var B bool = true
	
	d := arrA[0][0]*arrA[1][1] - arrA[0][1]*arrA[1][0]
	
	if d != 0 { // 역행렬이 존재하면 판별식이 0이 아니다.
		arrB[0][0] = arrA[1][1] / d
		arrB[0][1] = arrA[0][1] / -d
		arrB[1][0] = arrA[1][0] / -d
		arrB[1][1] = arrA[0][0] / d
		
		fmt.Println(B)
		
		for i := 0; i <= 1; i++ {
				fmt.Printf("%d %d\n", arrB[i][0], arrB[i][1])
		}
		
		
	} else {
		B = false
		fmt.Println(B)
	}
}
```
```go
> true
-2 3
5 -7
```

# 가장 긴 이름
```go
package main

import "fmt"

func main() {
  names := make([]string, 0)
	
	var name string

	for {
		fmt.Scan(&name)
		if name == "1" {
			break;
		} else {
			names = append(names, name);
		}
	}
	
	var result string = names[0]
	
	for i := 0; i < len(names); i++ {
		if len(result) < len(names[i]) {
			result = names[i];
		}
	}
	
	fmt.Println(result, len(result))
}
```

# 중간고사 평균 점수
```go
package main

import "fmt"

func main() {
	var m = make(map[string]int)
	var subject string
	var score int
	var avg float32

	for {
		fmt.Scanln(&subject, &score);
		if subject == "0" {
			break;
		} else {
			m[subject] = score
		}
	}

	for _, value := range m {
		avg += float32(value)
	}
	
	avg = avg / float32(len(m))

	for key, value := range m {
		fmt.Printf("%s %d\n", key, value)
	}
	fmt.Printf("%.2f", avg)
}
```